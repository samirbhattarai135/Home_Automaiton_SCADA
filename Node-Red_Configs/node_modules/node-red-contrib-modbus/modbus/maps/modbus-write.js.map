{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","createNode","this","name","showStatusActivities","showErrors","unitid","dataType","adr","Number","quantity","keepMsgProperties","verboseLogging","delayOnStart","settings","node","bufferMessageList","parseInt","Map","startDelayTime","delayOccured","inputDelayTimer","modbusClient","setNodeStatusTo","initModbusClientEvents","getNode","verboseWarn","logMessage","showWarnings","onModbusWriteDone","registerForModbus","send","resp","msg","errorProtocolMsg","buildMessage","payload","onModbusWriteError","err","origMsg","sendEmptyMsgOnFail","setModbusError","Object","hasOwnProperty","getOriginalMessage","value","indexOf","emit","parse","setMsgPayloadFromHTTPRequests","prototype","call","buildNewMessageObject","getObjectId","messageId","JSON","address","topic","id","fc","functionCodeModbusWrite","isReadyForInput","client","isActive","isNotReadyForInput","resetInputDelayTimer","clearTimeout","initializeInputDelayTimer","setTimeout","INPUT_TIMEOUT_MILLISECONDS","isInactive","assign","on","httpMsg","newMsg","done","origMsgInput","set","ModbusWrite","buildNewMessage","actualServiceState","clear","deregisterForModbus","setNodeDefaultStatus"],"mappings":"AAcAA,OAAAC,QAAA,SAAAC,GAEAF,QAAOC,oBAAuB,EAAEE,QAAA,EAC9B,IAAAC,EAAYC,QAAA,iBAAA,EAGNC,EAASD,QAAQ,oBAAoB,EAF3CA,EAAQA,QAAsBF,OAAS,EAAA,qBAAA,EAmLvCD,EAAIK,MAAMC,aAAa,eAjLvB,SAAuBC,GACvBP,EAAMQ,MAAAA,WAAmBL,KAAAA,CAAQ,EAG/BH,KAAIK,KAAMI,EAAAA,KAEVC,KAAKC,qBAAkBJ,EAAAK,qBACvBF,KAAKE,WAAAA,EAAoBC,WACzBH,KAAKG,aAAaN,EAAOM,aAGzBH,KAAKI,OAASP,EAAOO,OACrBJ,KAAKK,SAAWR,EAAOQ,SACvBL,KAAKM,IAAMC,OAAOV,EAAOS,GAAG,EAC5BN,KAAKQ,SAAWX,EAAOW,SAGvBR,KAAKS,eAAiBZ,EAAGA,eACzBG,KAAKF,kBAAmBA,EAAAA,kBACxBE,KAAKU,iBAAiBpB,EAEtBU,KAAKW,eAAed,EAAMe,SAACD,QAG3BX,KAAMa,aAAWhB,EAAAc,aACjBE,KAAKC,eAAiBC,SAAOC,EAAKC,cAAA,GAAA,GAElCJ,IAAKK,EAAAA,KAUL1B,GATAqB,EAAKM,kBAAkB,IAAIH,IAE3BxB,EAAAA,2BAAkC,IAElCqB,EAAMO,aAAe9B,CAAAA,EACrBuB,EAAKO,gBAAc,KAEnB5B,EAAA6B,gBAAA,UAAAR,CAAA,EAESS,EAAAA,MAAsBC,QAAOH,EAAAA,MAAa,GAyDnD,SAeEI,EAAAC,GACIZ,EAAID,SAACO,SAAiBN,EAAAa,cACxBF,EAAAA,KAAAA,aAAYC,CAAA,CAbhB,CA3DKE,IAHLP,EAMEQ,kBAAAf,CAAA,EALFrB,EAOOqC,uBAAyBhB,EAAKC,CAAAA,EAErCD,EAACc,kBAAA,SAAAG,EAAAC,GAEIC,EAAAA,sBACHxC,EAASW,gBAAY,aAAAU,CAAA,EAGtBA,EAAAgB,KAAAnC,EAAAuC,aAAApB,EAAAC,kBAAAiB,EAAAG,QAAAJ,EAAAC,CAAA,CAAA,EAEDlB,EAAKsB,KAAAA,qBAAqB,CAR1B,EAEAtB,EASEA,iBAAsBuB,SAAKC,EAAQN,GACnCvC,EAAS8C,YACT9C,EAAS+C,YAAc1B,EAAKuB,EAAEhB,CAAAA,CAEhC,EAPAP,EAUEsB,mBAAA,SAAAC,EAAAL,GACAlB,EAAI2B,iBAAiBC,EAAAA,OAAAA,EATrB,IAWMV,EAAIG,EAAaQ,mBAAmBR,EAAAA,kBAAkBH,CAAS,EAVrElB,EAWIkB,iBAAiBK,EAAOC,CAACH,EAV7B1C,EAWS8C,mBAAAzB,EAAAuB,EAAAL,CAAA,EAVTvC,EAWQuC,eAAYY,EAAMC,EAAiBR,EAAEC,CAAA,EAV7CxB,EAAKgC,KAWKX,sBAAqBY,CAVjC,EAEAjC,EAWEkC,8BAAA,SAAAhB,GACA,OACDS,OAAAQ,UAAAP,eAAAQ,KAAAlB,EAAAG,QAAA,OAAA,GAE4B,UAAzB,OAACgB,EAAAA,QAAAA,QACsBC,SAAnBC,EAAAA,QAAY1D,OAAoB,UAAAqC,EAAAG,QAAAS,MACtCZ,EAAOG,QAAAS,MAAA,SAAAZ,EAAAG,QAAAS,MAEI,CAAA,EAATS,EAASlB,QAATkB,MAASR,QAAA,GAAA,IACTV,EAAOA,QAAES,MAAAU,KAAAP,MAAAf,EAAAG,QAAAS,KAAA,IAIPW,CAXN,EAEAzC,EAYIqC,sBAAA,SAAArC,EAAAkB,GACF,IAACqB,EAAA1D,EAAAyD,YAAA,EACF,MAAA,CACDI,MAAAxB,EAAAwB,OAAA1C,EAAA2C,GACAJ,UAAAA,EACElB,QAAQtB,CACNC,MAAU2B,OAAAQ,UAAevB,eAAWwB,KAAAlB,EAAAG,QAAA,OAAA,EAAAH,EAAAG,QAAAS,MAAAZ,EAAAG,QACtC9B,OAAAS,EAAAT,OACFqD,GAAA/D,EAAAgE,wBAAA7C,EAAAR,QAAA,EAEKsD,QAAAA,EAAerD,IAClBE,SAAQY,EAAYZ,SACrB4C,UAAAA,CAEG,CACF,CACF,EANAvC,EAeEA,gBAAoB,WACrB,OAAAO,EAAAwC,QAAAxC,EAAAyC,SAAA,GAAAhD,EAAAK,YAEDL,EAdAA,EAgBEiD,mBAAuB,WAfvB,MAgBE,CAAAjD,EAAA8C,gBAAA,CAfJ,EAEA9C,EAAKkD,qBAgBqB,WAEvBlD,EAAMM,kBACLN,EAAKK,gCAAmBL,EAAA2C,EAAA,EAC1BQ,aAAAnD,EAAAM,eAAA,GAGFN,EAAKoD,gBAAAA,KAELpD,EAAOK,aAAU,CAAA,CAjBjB,EAEAL,EAkBIW,0BAAY,WAjBdX,EAkBEkD,qBAAA,EACFlD,EAAAF,cAEAa,EAASsC,qCAAsBjD,EAAA2C,EAAA,EAC7BhC,EAAAA,gBAAY0C,WAAA,WACZrD,EAAAK,aAAA,CAAA,CACF,EAAAL,EAAAsD,2BAAAtD,EAAAI,cAAA,GAEAJ,EAAIO,aAAagD,CAAAA,CAhBnB,EAEAvD,EAmBEoD,0BAA4BI,EAjB9BxD,EAmBIyD,GAAMC,QAAO,SAAQxB,GAjBvB,GAmBElC,EAAKC,iBAAsB0D,CAAAA,EAC3BpD,EAAY,2BAA2B,OAKzC,GAAEP,EAAOuB,mBAAK,EACZvB,EAAKmB,2CAAmC,MAD1C,CAMFnB,GAAKyD,EAAYF,WAAUK,EAEzB5D,OADArB,EAAS6B,mGAA+B,EACnCP,CAAAA,EAIFD,EAAKX,OAAoBmE,OAAE,GAAAtC,CAAA,EAC9BvC,IACF,IAAA+E,EAAA1D,EAAAkC,8BAAA2B,CAAA,EACFF,EAAA3D,EAAAqC,sBAAArC,EAAA0D,CAAA,EAEI5E,EAAMC,kBAAa+E,IAAAH,EAAgBI,UAAYpF,EAAAqF,gBAAAhE,EAAAJ,kBAAA8D,EAAAC,CAAA,CAAA,EACpDpD,EAAAyB,KAAA,cAAA2B,EAAA3D,EAAAc,kBAAAd,EAAAsB,kBAAA,EArBWtB,EAAKX,sBACPV,EAAS6B,gBAAgBD,EAAa0D,mBAAoBjE,CAAI,CAKlE,CAHE,MAAOuB,GACPvB,EAAKmB,iBAAiBI,EAAKsC,CAAY,EACvClF,EAAS8C,mBAAmBzB,EAAMuB,EAAKsC,CAAY,CACrD,CAAA,CACF,CAAC,EAED7D,EAAKyD,GAAG,QAAS,SAAUG,GACzBjF,EAAS6B,gBAAgB,SAAUR,CAAI,EACvCA,EAAKC,kBAAkBiE,MAAM,EAC7B3D,EAAa4D,oBAAoBnE,EAAK2C,GAAIiB,CAAI,CAChD,CAAC,EAEI5D,EAAKX,sBACRV,EAASyF,qBAAqBpE,CAAI,EAEtC,CAEkD,CACpD","file":"../modbus-write.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    const node = this\n    node.bufferMessageList = new Map()\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.delayOccured = false\n    node.inputDelayTimer = null\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('write done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n      node.emit('modbusWriteNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusWriteNodeError')\n    }\n\n    node.setMsgPayloadFromHTTPRequests = function (msg) {\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') &&\n        typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n      return msg\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: (Object.prototype.hasOwnProperty.call(msg.payload, 'value')) ? msg.payload.value : msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId\n        }\n      }\n    }\n    /* istanbul ignore next */\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.warn('Writer -> ' + logMessage)\n      }\n    }\n\n    node.isReadyForInput = function () {\n      return (modbusClient.client && modbusClient.isActive() && node.delayOccured)\n    }\n\n    node.isNotReadyForInput = function () {\n      return !node.isReadyForInput()\n    }\n\n    node.resetInputDelayTimer = function () {\n      /* istanbul ignore next */\n      if (node.inputDelayTimer) {\n        verboseWarn('reset input delay timer node ' + node.id)\n        clearTimeout(node.inputDelayTimer)\n      }\n      node.inputDelayTimer = null\n      node.delayOccured = false\n    }\n\n    node.initializeInputDelayTimer = function () {\n      node.resetInputDelayTimer()\n      if (node.delayOnStart) {\n        /* istanbul ignore next */\n        verboseWarn('initialize input delay timer node ' + node.id)\n        node.inputDelayTimer = setTimeout(() => {\n          node.delayOccured = true\n        }, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n      } else {\n        node.delayOccured = true\n      }\n    }\n\n    node.initializeInputDelayTimer()\n\n    node.on('input', function (msg) {\n      /* istanbul ignore next */\n      if (mbBasics.invalidPayloadIn(msg)) {\n        verboseWarn('Invalid message on input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (node.isNotReadyForInput()) {\n        verboseWarn('Inject while node is not ready for input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (modbusClient.isInactive()) {\n        verboseWarn('You sent an input to inactive client. Please use initial delay on start or send data more slowly.')\n        return false\n      }\n\n      const origMsgInput = Object.assign({}, msg)\n      try {\n        const httpMsg = node.setMsgPayloadFromHTTPRequests(origMsgInput)\n        const newMsg = node.buildNewMessageObject(node, httpMsg)\n        node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, httpMsg, newMsg))\n        modbusClient.emit('writeModbus', newMsg, node.onModbusWriteDone, node.onModbusWriteError)\n\n        if (node.showStatusActivities) {\n          mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}