{"version":3,"sources":["core/modbus-server-core.js"],"names":["require","install","_","de","biancoroyal","modbus","core","server","internalDebug","bufferFactor","memoryTypes","memoryUint16Types","memoryUint8Types","getLogFunction","node","internalDebugLog","isValidMemoryMessage","msg","payload","register","Number","address","isValidMessage","copyToModbusFlexBuffer","bufferData","copy","registers","bufferSplitAddress","coils","bufferAddress","writeToModbusFlexBuffer","writeUInt16BE","Buffer","isBuffer","bufferPayload","readUInt16BE","writeUInt8","readUInt8","parseInt","splitAddress","coreServer","convertInputForBufferWrite","_msg$payload","_msg$payload$value","value","isMultipleWrite","Uint8Array","wasMultipleWrite","alloc","buffer","byteLength","copyToModbusBuffer","modbusServer","holding","input","discrete","writeToModbusBuffer","toLowerCase","writeToServerMemory","writeToFlexServerMemory","writeModbusServerMemory","err","writeModbusFlexServerMemory","undefined","exports","includes","error","module"],"mappings":"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","file":"../../core/modbus-server-core.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nconst _ = require('underscore')\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { core: { server: { } } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.server.internalDebug = de.biancoroyal.modbus.core.server.internalDebug || require('debug')('contribModbus:core:server') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.core.server.bufferFactor = 8\nde.biancoroyal.modbus.core.server.memoryTypes = ['holding', 'coils', 'input', 'discrete']\nde.biancoroyal.modbus.core.server.memoryUint16Types = ['holding', 'input']\nde.biancoroyal.modbus.core.server.memoryUint8Types = ['coils', 'discrete']\n\nde.biancoroyal.modbus.core.server.getLogFunction = function (node) {\n  if (node.internalDebugLog) {\n    return node.internalDebugLog\n  } else {\n    return de.biancoroyal.modbus.core.server.internalDebug\n  }\n}\n\nde.biancoroyal.modbus.core.server.isValidMemoryMessage = function (msg) {\n  return _.isUndefined(msg.payload) === false &&\n    msg.payload.register &&\n    Number.isInteger(msg.payload.address) &&\n    msg.payload.address >= 0 &&\n    msg.payload.address <= 65535\n}\n\nde.biancoroyal.modbus.core.server.isValidMessage = function (msg) {\n  return _.isUndefined(msg) === false && _.isUndefined(msg.payload) === false\n}\n\nde.biancoroyal.modbus.core.server.copyToModbusFlexBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      msg.bufferData.copy(node.registers, msg.bufferSplitAddress)\n      break\n    case 'coils':\n      msg.bufferData.copy(node.coils, msg.bufferAddress)\n      break\n    case 'input':\n      msg.bufferData.copy(node.registers, msg.bufferAddress)\n      break\n    case 'discrete':\n      msg.bufferData.copy(node.coils, msg.bufferSplitAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeToModbusFlexBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      node.registers.writeUInt16BE((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt16BE(0) : msg.bufferPayload, msg.bufferSplitAddress)\n      break\n    case 'coils':\n      node.coils.writeUInt8((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt8(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'input':\n      node.registers.writeUInt16BE((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt16BE(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'discrete':\n      node.coils.writeUInt8((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt8(0) : msg.bufferPayload, msg.bufferSplitAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeModbusFlexServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.bufferSplitAddress = (parseInt(msg.payload.address) + parseInt(node.splitAddress)) * coreServer.bufferFactor\n  msg.bufferAddress = parseInt(msg.payload.address) * coreServer.bufferFactor\n\n  if (coreServer.convertInputForBufferWrite(msg)) {\n    return coreServer.copyToModbusFlexBuffer(node, msg)\n  } else {\n    return coreServer.writeToModbusFlexBuffer(node, msg)\n  }\n}\n\nde.biancoroyal.modbus.core.server.convertInputForBufferWrite = function (msg) {\n  let isMultipleWrite = false\n  if (msg.payload.value?.length) {\n    msg.bufferPayload = new Uint8Array(msg.payload?.value)\n    msg.bufferData = Buffer.alloc(msg.bufferPayload.buffer.byteLength, msg.bufferPayload)\n    isMultipleWrite = true\n    msg.wasMultipleWrite = true\n  } else {\n    msg.bufferPayload = Number(msg.payload.value)\n    msg.wasMultipleWrite = false\n  }\n\n  return isMultipleWrite\n}\n\nde.biancoroyal.modbus.core.server.copyToModbusBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      msg.bufferData.copy(node.modbusServer.holding, msg.bufferAddress)\n      break\n    case 'coils':\n      msg.bufferData.copy(node.modbusServer.coils, msg.bufferAddress)\n      break\n    case 'input':\n      msg.bufferData.copy(node.modbusServer.input, msg.bufferAddress)\n      break\n    case 'discrete':\n      msg.bufferData.copy(node.modbusServer.discrete, msg.bufferAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeToModbusBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      node.modbusServer.holding.writeUInt16BE((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt16BE(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'coils':\n      node.modbusServer.coils.writeUInt8((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt8(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'input':\n      node.modbusServer.input.writeUInt16BE((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt16BE(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'discrete':\n      node.modbusServer.discrete.writeUInt8((Buffer.isBuffer(msg.bufferPayload)) ? msg.bufferPayload.readUInt8(0) : msg.bufferPayload, msg.bufferAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeModbusServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.bufferAddress = parseInt(msg.payload.address) * coreServer.bufferFactor\n\n  if (coreServer.convertInputForBufferWrite(msg)) {\n    return coreServer.copyToModbusBuffer(node, msg)\n  } else {\n    return coreServer.writeToModbusBuffer(node, msg)\n  }\n}\n\nde.biancoroyal.modbus.core.server.writeToServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.payload.register = msg.payload.register.toLowerCase()\n  try {\n    if (coreServer.memoryTypes.includes(msg.payload.register)) {\n      coreServer.writeModbusServerMemory(node, msg)\n    }\n  } catch (err) {\n    msg.error = err\n    node.error(err)\n  }\n}\n\nde.biancoroyal.modbus.core.server.writeToFlexServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.payload.register = msg.payload.register ? msg.payload.register.toLowerCase() : undefined; try {\n    if (coreServer.memoryTypes.includes(msg.payload.register)) {\n      coreServer.writeModbusFlexServerMemory(node, msg)\n    }\n  } catch (err) {\n    msg.error = err\n    node.error(err)\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.core.server\n"]}