{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","mapping","addressOffset","Number","logIOActivities","valueAddress","startsWith","insertValues","buildOutputAddressMapping","allValueNamesFromIOFile","ioNode","convertValuesByType","forEach","buildInputAddressMapping","push","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStartIO","addressStart","coilStart","bits","bitAddress","addressType","substring","registerType","split","Math","floor","register","name","addressOffsetIO","registerAddress","Bit","dataType","error","item","index","call","JSON","stringify","isRegisterSizeWrong","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","lowBits","highBits","registerLength","length","readUInt16BE","readInt8","readInt32BE","convertedValue","readFloatBE","readUInt32BE","readInt16BE","readDoubleBE","readUInt8","sixteenBitBufferLength","buffer","Object","prototype","hasOwnProperty","err","Buffer","functionType","startRegister","filterValueNames","fc","message","quantity","endRegister","origMsg","sizeDivisor","filter","topic","adr","rawMsg","payload","valueName","allValueNames","useIOForPayload","start","buildMessageWithIO","this","getOriginalMessage","bufferMessageList","modbusRequest","assign","useIOFile","lastUpdatedAt","parseInt","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  const valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'input'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match input mapping' }\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'output'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match output mapping' }\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    const item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  const registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n  let lowBits\n  let highBits\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          lowBits = responseBuffer.readUInt32BE(4)\n          highBits = responseBuffer.readUInt32BE(0)\n          item.value = highBits * 2 ** 32 + lowBits\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  const sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        /* istanbul ignore next */\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  const ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  const startRegister = adr\n  const endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  const sizeDivisor = Number(bits) || 16\n  const startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.modbusRequest = Object.assign({}, msg.payload)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n\n  const rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg.responseBuffer\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}