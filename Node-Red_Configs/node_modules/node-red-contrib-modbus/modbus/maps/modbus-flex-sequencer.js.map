{"version":3,"sources":["modbus-flex-sequencer.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","createNode","this","name","sequences","showStatusActivities","showErrors","showWarnings","connection","ioFile","getNode","useIOForPayload","logIOActivities","emptyMsgOnFail","verboseLogging","settings","delayOnStart","startDelayTime","Number","verbose","node","bufferMessageList","INPUT_TIMEOUT_MILLISECONDS","inputDelayTimer","onModbusReadDone","Map","modbusClient","registerForModbus","server","Error","setNodeStatusTo","delayOccured","warn","logMessage","initModbusClientEvents","resp","msg","data","origMsg","setModbusError","logMsgError","err","message","getOriginalMessage","errorProtocolMsg","fc","emit","prepareMsg","JSON","parse","unitid","address","quantity","isValidModbusMsg","error","parseInt","isInteger","topic","messageId","verboseWarn","keepMsgProperties","payload","isNotReadyForInput","isReadyForInput","resetInputDelayTimer","id","clearTimeout","initializeInputDelayTimer","client","isActive","invalidSequencesIn","buildNewMessageObject","newMsg","invalidPayloadIn","origMsgInput","Object","assign","forEach","inputMsg","set","buildNewMessage","onModbusReadError","sendEmptyMsgOnFail","actualServiceState","on","done","clear","deregisterForModbus","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-sequencer.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a>Andrea Verardi</a> (Anversoft)\n */\n\n/**\n * Modbus Sequencer node.\n * @module NodeRedModbusFlexSequencer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:poller')\n\n  function ModbusFlexSequencer (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.sequences = config.sequences\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = Number(config.startDelayTime) || 10\n\n    const node = this\n    node.bufferMessageList = new Map()\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.delayOccured = false\n    node.inputDelayTimer = null\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      throw new Error('Modbus client not found')\n    }\n\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexSequencerNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexSequencerNodeError')\n    }\n\n    node.prepareMsg = (msg) => {\n      if (typeof msg === 'string') {\n        // NOTE: The operation can fail!\n        msg = JSON.parse(msg)\n      }\n\n      switch (msg.fc) {\n        case 'FC1':\n          msg.fc = 1\n          break\n        case 'FC2':\n          msg.fc = 2\n          break\n        case 'FC3':\n          msg.fc = 3\n          break\n        case 'FC4':\n          msg.fc = 4\n          break\n      }\n\n      msg.unitid = parseInt(msg.unitid)\n      msg.address = parseInt(msg.address) || 0\n      msg.quantity = parseInt(msg.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      // let isValid = true\n      // The original author did isValid &= false i replaced it with a simple early return if that breaks something\n      // we should change it back to the original value.\n      if (!(Number.isInteger(msg.unitid) &&\n          msg.unitid >= 0 &&\n          msg.unitid <= 255)) {\n        node.error('Unit ID Not Valid', msg)\n        return false\n      }\n\n      if (!(Number.isInteger(msg.address) &&\n          msg.address >= 0 &&\n          msg.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        return false\n      }\n\n      if (!(Number.isInteger(msg.quantity) &&\n          msg.quantity >= 1 &&\n          msg.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        return false\n      }\n\n      return true\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          name: msg.name,\n          unitid: msg.unitid,\n          fc: msg.fc,\n          address: msg.address,\n          quantity: msg.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n    /* istanbul ignore next */\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.warn('Flex-Sequencer -> ' + logMessage)\n      }\n    }\n\n    node.isReadyForInput = function () {\n      return (modbusClient.client && modbusClient.isActive() && node.delayOccured)\n    }\n\n    node.isNotReadyForInput = function () {\n      return !node.isReadyForInput()\n    }\n\n    node.resetInputDelayTimer = function () {\n      /* istanbul ignore next */\n      if (node.inputDelayTimer) {\n        verboseWarn('reset input delay timer node ' + node.id)\n        clearTimeout(node.inputDelayTimer)\n      }\n      node.inputDelayTimer = null\n      node.delayOccured = false\n    }\n\n    node.initializeInputDelayTimer = function () {\n      node.resetInputDelayTimer()\n      if (node.delayOnStart) {\n        /* istanbul ignore next */\n        verboseWarn('initialize input delay timer node ' + node.id)\n        node.inputDelayTimer = setTimeout(() => {\n          node.delayOccured = true\n        }, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n      } else {\n        node.delayOccured = true\n      }\n    }\n\n    node.initializeInputDelayTimer()\n\n    node.on('input', (msg) => {\n      /* istanbul ignore next */\n      if (mbBasics.invalidPayloadIn(msg)) {\n        verboseWarn('Invalid message on input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (node.isNotReadyForInput()) {\n        verboseWarn('Inject while node is not ready for input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (modbusClient.isInactive()) {\n        verboseWarn('You sent an input to inactive client. Please use initial delay on start or send data more slowly.')\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg)\n      const sequences = mbBasics.invalidSequencesIn(msg) ? node.sequences : msg.sequences\n\n      try {\n        sequences.forEach(msg => {\n          const inputMsg = node.prepareMsg(msg)\n          if (node.isValidModbusMsg(inputMsg)) {\n            const newMsg = node.buildNewMessageObject(node, inputMsg)\n            node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n            modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n          }\n        })\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', (done) => {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-sequencer', ModbusFlexSequencer)\n}\n"]}