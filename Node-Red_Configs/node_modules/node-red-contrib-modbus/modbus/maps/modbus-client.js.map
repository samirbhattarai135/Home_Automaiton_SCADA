{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusClient","nodes","registerType","this","config","ModbusRTU","defaultTcpUnitId","reconnectTimeMS","serverInfo","clienttype","bufferCommands","undefined","failureLogEnabled","tcpHost","stateLogEnabled","tcpPort","serialPort","serialBaudrate","serialDatabits","serialParity","serialType","serialConnectionDelay","parseInt","serialAsciiResponseStartDelimiter","unit_id","commandDelay","clientTimeout","timeoutTimeMS","serialConnectionDelayTimeMS","reconnectTimeout","parallelUnitIdsAllowed","reconnectOnTimeout","showLogs","showWarnings","node","bufferCommandList","showErrors","sendingAllowed","Map","unitSendingAllowed","verboseWarn","logMessage","settings","verbose","stateLog","actualServiceStateBefore","actualServiceState","state","value","stateMachine","stateService","reconnectTimeoutId","messageAllowedStates","serialSendingAllowed","coreModbusQueue","queueSerialLockCommand","setDefaultUnitId","createStateMachineService","initialState","defaultUnitId","startStateService","setUnitIdFromPayload","unitId","client","msg","Number","minCommandDelayMilliseconds","checkUnitId","updateServerinfo","errorProtocolMsg","queueLog","verboseLog","err","matches","queueLogEnabled","subscribe","isFirstInitOfConnection","setTimeout","connectClient","initQueue","send","logHintText","queueSerialUnlockCommand","emit","dequeueCommand","checkQueuesAreEmpty","close","payload","connectC701","setTCPConnectionOptions","message","port","modbusErrorHandling","then","error","Error","autoOpen","modbusTcpErrorHandling","setTCPConnected","connectTelnet","connectTcpRTUBuffered","connectUDP","serialPortOptions","baudRate","dataBits","connectTCP","startOfSlaveFrameChar","modbusSerialErrorHandling","e","connectRTU","connectRTUBuffered","stopBits","serialStopbits","parity","setID","modbusSerialDebug","setSerialConnectionOptions","openSerialClient","toString","connectAsciiSerial","errno","networkErrors","_port","onModbusClose","JSON","stringify","includes","on","isInactive","cberr","pushToQueueByUnitId","readModbus","code","queueLength","get","queueUnitId","cb","resolve","reject","setMaxListeners","length","invalidPayloadIn","nodeIdentifierName","writeModbus","internalDebugLog","activateSending","set","info","removeAllListeners","registeredNodeList","clientUserNodeId","setStoppedState","Object","closingModbus","internalDebug","deregisterForModbus","done","closeConnectionWithoutRegisteredNodes","isOpen","isActive","isUndefined","SerialPort","ports","res","json","registerForModbus","keys","_","indexOf","isReadyToSend","httpAdmin","auth","needsPermission","req","list"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n  const _ = require('underscore')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('@openp4nr/modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n    const serialAsciiResponseStartDelimiter = '0x3A'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n    this.failureLogEnabled = config.failureLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter || serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.showLogs = config.showLogs\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messageAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n    /* istanbul ignore next */\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.updateServerinfo()\n        node.warn('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose && node.showLogs) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        /* istanbul ignore next */\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            /* istanbul ignore next */\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            /* istanbul ignore next */\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          /* istanbul ignore next */\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          if (!node.parallelUnitIdsAllowed) {\n            if (node.serialSendingAllowed) {\n              coreModbusQueue.queueSerialLockCommand(node)\n              node.stateService.send('SEND')\n            }\n          } else {\n            node.stateService.send('SEND')\n          }\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      /* istanbul ignore next */\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        /* istanbul ignore next */\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      try {\n        if (node.client) {\n          try {\n            node.client.close(function () {\n              verboseLog('connection closed')\n            })\n            verboseLog('connection close sent')\n          } catch (err) {\n            verboseLog(err.message)\n          }\n        }\n        node.client = null\n        node.client = new ModbusRTU()\n\n        node.client.on('error', (err) => {\n          node.modbusErrorHandling(err)\n          mbBasics.setNodeStatusTo('error', node)\n        })\n\n        if (!node.clientTimeout) {\n          node.clientTimeout = timeoutTimeMS\n        }\n\n        if (!node.reconnectTimeout) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n\n        if (node.clienttype === 'tcp') {\n          /* istanbul ignore next */\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          try {\n            switch (node.tcpType) {\n              case 'C701':\n                verboseLog('C701 port UDP bridge')\n                node.client.connectC701(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .then(node.setTCPConnected)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TELNET':\n                verboseLog('Telnet port')\n                node.client.connectTelnet(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              /* istanbul ignore next */\n              case 'TCP-RTU-BUFFERED':\n                verboseLog('TCP RTU buffered port')\n                node.client.connectTcpRTUBuffered(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'UDP':\n                verboseLog('UDP port')\n                node.client.connectUDP(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('TCP port')\n                node.client.connectTCP(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n            }\n          } /* istanbul ignore next */ catch (e) {\n            node.modbusTcpErrorHandling(e)\n            return false\n          }\n        } else {\n          /* istanbul ignore next */\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          if (!node.serialConnectionDelay) {\n            node.serialConnectionDelay = serialConnectionDelayTimeMS\n          }\n\n          if (!node.serialPort) {\n            node.error(new Error('wrong serial port'), { payload: node.serialPort })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          const serialPortOptions = {\n            baudRate: parseInt(node.serialBaudrate),\n            dataBits: parseInt(node.serialDatabits),\n            stopBits: parseInt(node.serialStopbits),\n            parity: node.serialParity,\n            autoOpen: false\n          }\n\n          try {\n            switch (node.serialType) {\n              case 'ASCII':\n                verboseLog('ASCII port serial')\n                // Make sure is parsed when string, otherwise just assign.\n                if (node.serialAsciiResponseStartDelimiter && typeof node.serialAsciiResponseStartDelimiter === 'string') {\n                  serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n                } else {\n                  serialPortOptions.startOfSlaveFrameChar = node.serialAsciiResponseStartDelimiter\n                }\n                verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n\n                node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'RTU':\n                verboseLog('RTU port serial')\n                node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('RTU buffered port serial')\n                node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n            }\n          } /* istanbul ignore next */ catch (e) {\n            node.modbusSerialErrorHandling(e)\n            return false\n          }\n        }\n      } /* istanbul ignore next */ catch (err) {\n        node.modbusErrorHandling(err)\n        return false\n      }\n\n      return true\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n        (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      /* istanbul ignore next */\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('customModbusMessage', function (msg, cb, cberr) {\n      // const state = node.actualServiceState\n      coreModbusClient.customModbusMessage(node, msg, cb, cberr)\n    })\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      try {\n        coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n        if (coreModbusClient.setNewNodeSettings(node, msg)) {\n          cb(msg)\n        } else {\n          cberr(new Error('Message Or Payload Not Valid'), msg)\n        }\n        coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n        node.stateService.send('SWITCH')\n      } catch (err) {\n        cberr(err, msg)\n      }\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              /* istanbul ignore next */\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              /* istanbul ignore next */\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          /* istanbul ignore next */\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n\n        node.client.removeAllListeners()\n      } else {\n        /* istanbul ignore next */\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n\n      node.removeAllListeners()\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        /* istanbul ignore next */\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n\n    node.isInactive = function () {\n      return _.isUndefined(node.actualServiceState) || node.messageAllowedStates.indexOf(node.actualServiceState.value) === -1\n    }\n\n    node.isActive = function () {\n      return !node.isInactive()\n    }\n\n    node.isReadyToSend = function (node) {\n      if (node.actualServiceState.matches('queueing') || node.actualServiceState.matches('activated')) {\n        return true\n      }\n\n      verboseWarn('Client not ready to send')\n      return false\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  /* istanbul ignore next */\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      /* istanbul ignore next */\n      res.json([err.message])\n      /* istanbul ignore next */\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}