{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","modbus","require","net","nodes","registerType","config","internalDebugLog","this","name","logEnabled","hostname","serverPort","parseInt","responseDelay","delayUnit","showStatusActivities","coilsBufferSize","holdingBufferSize","inputBufferSize","discreteBufferSize","verboseLogging","node","settings","verbose","modbusServer","modbusLogLevel","mbBasics","netServer","coils","alloc","holding","input","Buffer","discrete","calc_rateByUnit","client","socket","listen","setNodeStatusTo","JSON","stringify","address","remoteAddress","remotePort","setNodeDefaultStatus","message","err","showErrors","msg","payload","type","disableMsgOutput","buildMessage","error","on","coreServer","isValidMemoryMessage","writeToServerMemory","isValidMessage","send","done","close","removeAllListeners"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n  const coreServer = require('./core/modbus-server-core')\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay) || 1\n    this.delayUnit = config.delayUnit\n    this.showStatusActivities = config.showStatusActivities || false\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      /* istanbul ignore next */\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n\n      if (!node.showStatusActivities) {\n        mbBasics.setNodeDefaultStatus(node)\n      }\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.netServer.on('error', function (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    })\n\n    node.on('input', function (msg) {\n      if (coreServer.isValidMemoryMessage(msg)) {\n        coreServer.writeToServerMemory(node, msg)\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      } else {\n        if (node.showErrors) {\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\n        }\n        if (coreServer.isValidMessage(msg) && !msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      }\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\n        { payload: 'request', type: 'message', message: msg }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n          node.removeAllListeners()\n          node.netServer.removeAllListeners()\n        })\n      } else {\n        done()\n        node.removeAllListeners()\n      }\n\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    /* istanbul ignore next */\n    internalDebugLog(err.message)\n  }\n}\n"]}